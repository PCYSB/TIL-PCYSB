# 제목 없음

03-2 명령어의 구조

# 연산 코드와 오퍼랜드

- 명령어는 연산 코드와 오퍼랜드로 구성되어 있다. 연산 코드는 **연산자**, 오퍼랜드는 **피연산자**라고도 부른다.
- 연산 코드가 담기는 영역을 연산 코드 필드, 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다.
- 기계어와 어셈블리어 또한 명령어이기에 연산 코드와 오퍼랜드로 구성되어 있다.

## 연산 코드

명령어가 수행할 연산을 연산 코드라 한다. 명령어의 종류와 생김새는 CPU마다 다르기 때문에 연산 코드의 종류와 생김새 또한 CPU마다 다르다.
가장 기본적인 연산 코드의 유형은 크게 네 가지로 나눌 수 있다.

- 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어

## 오퍼랜드

연산에 사용할 데이터가 저장된 위치를 오퍼랜드라고 한다. 연산에 사용할 데이터가 저장된 위치도 담기에 **주소 필드**라고도 부른다.
오퍼랜드의 수에 따라 명령어를 n-주소 명령어라고 부른다.

- 연산에 사용할 데이터, 연산에 사용될 데이터가 저장된 위치를 의미한다.
- 여기에는 데이터 그 자체, 메모리, 레지스터 주소등이 올 수 있다.
- 대부분의 경우에는 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나, 레지스터 이름이 담긴다.

> 왜 오퍼랜드 필드에 그냥 연산에 사용할 데이터를 담으면 될 텐데 왜 주소를 담는 것인가? 이는 명령어의 길이 때문이다. 예를 들어 16 비트의 명령어가 있다고 치고 이중 4비트는 연산 코드이고 2-주소 명령어 라면 오퍼랜드 필드당 6비트 정도 밖에 남지 않게 된다. 즉 표현할 수 있는 가짓수가 상당히 적어진다는 것이다. 그래서 오프랜드 필드 안에 메모리 주소가 담긴다면 메모리 주소에 저장할 수 있는 크기만큼 표현할 수 있는 데이터가 커진다.
> 
- 오퍼랜드는 명령어 안에 없을 수도, 여러개가 있을 수도 있다.

# 유효 주소와 주소 지정 방식

위에서 말한 것 처럼 오퍼랜드에는 대부분의 경우 메모리나 레지스터의 주소 값이 들어간다. 연산의 대상이 되는 데이터가 저장된 위치를 유효 주소라 하고 그 유효 주소를 찾는 방법을 주소 지정 방식이라고 한다.

## 주소 지정 방식

연산의 사용할 데이터의 위치를 찾는 방법 즉 유효 주소의 위치를 찾는 방식이다. 대표적인 주소 지정 방식은 다섯 가지가 있다.

### 즉시 주소 지정 방식

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다.
- 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만 연산에 필요한 데이터를 찾는 과정이 없기 때문에 지금 설명할 주소 지정 방식들중에는 가장 빠르다.

### 직접 주소 지정 방식

- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식이다.
- 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉지 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다.
- 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

### 간점 주소 지정 방식

- 유효 주소의 주소를 오퍼랜드 필드에 명시한다.
- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓다.
- 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식들 보다 일반적으로 느린 방식

### 레지스터 주소 지정 방식

- 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
- 일반적으로 cpu 외부에 접근하는 것 보다는 cpu 내부에 접근 하는 것이 더 빠르기에 빠르다.
- 직접 주소 지정 방식과 같은 문제점을 공유한다. 표현할 수 있는 크기의 제한

### 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
- 간접 주소 지정 방식과 비슷하지만 메모리에 접근 하는 횟수가 한 번으로 줄어든다.