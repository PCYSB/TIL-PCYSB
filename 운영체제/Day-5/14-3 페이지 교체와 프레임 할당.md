14-3 페이지 교체와 프레임 할당

# 요구 페이징
쉽게 말해 프로세스를 메모리에 적재 할 시 **처음부터** 필요한 페이지만을 메모리에 적재하는 기법이다.
- 모든 페이지를 적재하지 않음
- 실행에 필요한 페이지만을 적재(시작시)

> 요구 페이징 시스템이 안정적으로 작동하려면 필연적으로 **페이지 교체** **프레임 할당**을 해결해야 한다.
> 이중 페이지 교체는 요구 페이징 기법으로 페이지를 적재시 언젠가 메모리가 가득 차게 된다. 이때 당장 필요한 페이지의 실행을 위하여 메모리에 적재된 페이지를 보조기억장치로 내보내야한다. 이 중 어떤 페이지를 내보내는 것이 최선인가를 결정하는 방법이 **페이지 교체 알고리즘**이다.

### 요구 페이징의 기본 양상
1. CPU가 특정 페이지에 접근하는 명령어 실행
2. 유효 비트가 1 일경우 CPU는 페이지가 적재된 프레임에 접근한다.
3. 유효 비트가 0일 경우 페이지 폴트 발생
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 다시 1번을 수행


# 순수 요구 페이징
프로세스를 메모리에 적재 할 시 **아무런 페이지도 적재하지 않은 채** 무작정 실행하는 기법
- 첫 명령어를 실행하는 순간부터 페이지 폴트 발생
- 실행에 필요한 페이지가 어느 정도 적재된 후 부터 페이지 폴트 발생 빈도 하락

# 페이지 교체 알고리즘
일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가한다.

- 그렇기에 페이지 교체 알고리즘을 제대로 이해하기위해서는 페이지 폴트 횟수를 알 수 있어야한다.
- 페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있다.
- 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않는다.(중요한건 페이지가 프레임에 있느냐 없느냐의 문제이니)

## FIFO 페이지 교체 알고리즘
메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식이다.

- 아이디어와 구현은 간단하다.
- 하지만 자주 사용하는 페이지의 경우에도 메모리에 먼저 적재되었다는 이유 하나만으로 내쫓아질 수 있다.

![alt text](<스크린샷 2024-04-17 221231.png>)

## 2차 기회 페이지 교체 알고리즘
기본적으로는 FIFO 페이지 교체 알고리즘의 틀을 따르나 참조 비트를 확인하여 1일 경우 참조 비트를 0으로 만든 뒤 현재 시간을 적재 시간으로 설정한다.

- 쉽게 말해 FIFO 페이지 교체 알고리즘에서 조건에 부합하다면 한 번더 기회를 주는 것이다.
- 조건은 참조 비트가 되겠다.
![alt text](<스크린샷 2024-04-17 221250.png>)
![alt text](<스크린샷 2024-04-17 221257.png>)


## 최적 페이지 교체 알고리즘
앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.

- 페이지 폴트를 가장 적게 발생 시키는 방법은 자주 사용되는 페이지를 내보내지 않는 것이다.
- 따라서 내보내야 할 페이지는 사용빈도가 가장 낮은 페이지이다.
![alt text](<스크린샷 2024-04-18 031955.png>)

- 가장 낮은 페이지 폴트율을 보장하는 알고리즘이며, 타 페이지 교체 알고리즘에 비해 페이지 폴트 발생 빈도는 가장 낮다.
- 하지만 실제 구현이 어렵다.
- 앞으로 오랫동안 사용되지 않을 페이지를 예측하는 일과, 프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 미리 아는 일은 굉장히 어려우며 불가능에 가깝다.
- 떄문에 주로 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용된다.

## LRU 페이지 교체 알고리즘
Least Recently Used Page Replacement Algorithm, 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘이다.
![alt text](<스크린샷 2024-04-18 034424.png>)

# 스래싱과 프레임 할당
스래싱이란 지나치게 빈번한 페이지 교체로 인해 CPU 이용률이 낮아지는 문제를 말한다.

![alt text](<스크린샷 2024-04-18 040740.png>)

- 페이지 폴트가 자주 발생하는 이유는 나쁜 페이지 교체 알고리즘 뿐만 아니라 프레임 수가 적어도 페이지 폴트가 자주 발생한다.
- 때문에 프레임 수가 많다면 페이지 폴트의 빈도는 감소한다.
- 페이지 폴트가 빈번히 발생한다면(프레임이 부족하여) CPU가 쉴새 없이 일을 할 수 없어 컴퓨터 전체의 생산성이 하락한다.

![alt text](<스크린샷 2024-04-18 040748.png>)


스래싱을 그림으로 표현하자면 아래와 같다.
- CPU이용률이 높으면 CPU는 현재 일을 쉬지 않고 하고 있다는 의미, 낮다면 CPU는 현재 일을 많이 하고 있지 않다는 것을 의미
- 가로축인 멀티 프로그래밍의 정도를 통하여 메모리에 올라와 있는 프로세스의 수를 알 수 있다.
- 메모리에서 동시에 실행되는 프로세스의 수를 멀티프로그래밍의 정도라고 한다.

![alt text](<스크린샷 2024-04-18 040754.png>)

해당 그래프에서 동시에 실행되는 프로세스의 수를 늘린다고 해서 CPU 이용륭이 증가하는 것은 아니라는 것을 알 수 있다.
- 동시에 실행되는 프로세스 수가 어느 정도 증가하면 CPU 이용률이 높아 진다.
- 하지만 필요 이상으로 늘린다면 각 프로세스들이 사용할 수 있는 프레임의 수가 줄어들기에 페이지 폴트가 빈번하게 발생한다.
- 결과적으로 CPU 이용률이 떨어져 전체적인 성능이 저해된다.

## 정적 할당 방식
프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려한 방식

### 균등 할당
모든 프로세스에 균등하게 프레임을 제공하는 방식
- 예를 들어 세 개의 프로세스에 총 300개의 프레임을 할당할 수 있다면 각 프로세스에 100개의 프레임을 할당하는 방식이다.

### 비례 할당
프로세스의 크기에 따라서 프레임을 할당하는 방식
- 프로세스의 크기가 클시 프레임을 많이 할당하고 프로세스의 크기가 작을시 프레임을 적게 나눠 주는 방식

## 동적 할당 방식
프로세스의 실행을 보고 할당할 프레임 수를 결정
- 정적 할당 방식의 경우 프로세스의 실행을 보지 않고 물리적인 크기만을 보고 결정하기에 실제로 프로세스가 프레임을 얼마나 사용하는지 알 수 없다.
- 하나의 프로세스가 실제로 얼마나 많은 프레임이 필요한지는 결국 실행해 봐야 아는 경우가 많기 때문이다.

### 작업 집합 모델
작업 집합의 크기만큼만 프레임을 할당하는 방식
- 작업 집합이란 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 말한다.
- 이 작업 집합을 이용하여 빈번한 페이지 교체를 방지할 수 있다.
- 해당 방법이 가능한 이유는 한 프로세스의 모든 페이지를 고르게 참조하는 것이 아닌, 특정 시간 동안에는 몇몇 개의 페이지만을 집중적으로 참조하기 때문이다.

작업 집합을 구하는 방식은 아래와 같다
- 기본적으로 아래 두가지가 필요
- 프로세스가 참조한 페이지
- 일정 시간 간격

![alt text](<스크린샷 2024-04-18 050957.png>)
![alt text](<스크린샷 2024-04-18 051002-1.png>)
![alt text](<스크린샷 2024-04-18 051013.png>)

### 페이지 폴트 빈도
페이지 폴트 빈도를 기반으로 한 프레임 할당은 아래 두 개의 가정에서 생겨났다.
- 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.
- 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다.

해당 부분을 그래프로 표현하면 아래와 같다.
- 폴트율이 높으면 프레임이 적고
- 플트율이 낮으면 프레임이 많다는 것이다.
![alt text](<스크린샷 2024-04-18 051022.png>)

즉 폴트율이 너무 높다면 프레임을 더 할당하고, 폴트율이 너무 낮다면 프레임을 회수한다.
![alt text](<스크린샷 2024-04-18 051029.png>)