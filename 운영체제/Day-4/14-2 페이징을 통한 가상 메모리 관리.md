14-2 페이징을 통한 가상 메모리 관리

# 연속 메모리 할당의 문제
- 외부 단편화
  - 근본적 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문

![alt text](<스크린샷 2024-04-15 041646.png>)
- 물리 메모리보다 큰 프로세스를 실행할 수 없다.

4GB 메모리가 설치된 컴퓨터로는 4GB 이상의 프로그램을 실행할 수 없다.
![alt text](<스크린샷 2024-04-15 041629.png>)


# 페이징이란
메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로도 할당하면 외부 단편화는 발생하지 않는다. 이것이 페이징 이다.
- 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자른다.
- 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

![alt text](<스크린샷 2024-04-15 041658.png>)

![alt text](<스크린샷 2024-04-15 041718.png>)

## 페이징에서의 스와핑
페이징에서도 스와핑을 사용 가능하다.
- 단 페이지 단위로 스왑 아웃/스왑 인 된다.
- 페이징에서는 페이지 아웃, 페이지 인 이라고도 부른다.
![alt text](<스크린샷 2024-04-15 041724.png>)

방금 페이지 단위로 스왑 아웃/스왑 인이 된다고 하였는데 이는 매우 중요하다.
- 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요 없다는 말이다.
- 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 실행에 필요하지 않은 페이지는 보조기억장치에 남겨 둠으로서 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.

# 페이지 테이블
페이지 번호와 프레임 번호를 짝지어주는 일종의 이정표
- 페이징 방식에서는 프로세스가 메모리에 불연속적으로 배치 되어 있다. 이는 CPU 입장에서 이를 순차적으로 실행할 수 없다. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문이다.
- 이를 해결 하기위해 페이징 시스템은 프로세스가 물리 주소에는 불연속적으로 배치되더라도 논리 주세이는 연속적으로 배치되도록 **페이지 테이블**을 이용한다.
- CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다.

![alt text](<스크린샷 2024-04-15 043753.png>)

![alt text](<스크린샷 2024-04-15 044305.png>)

## PTBR
- 프로세스마다 페이지 테이블을 갖고 있다.
- 페이지 테이블은 메모리에 적재되어있다.
- CPU 내의 **페이지 테이블 베이스 레지스터(PTBR)**는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
![alt text](<스크린샷 2024-04-15 051914.png>)

해당 방법에서는 메모리 접근 시간이 두 배로 늘어난다.
- 페이지 테이블을 참조하기 위해 한 번
- 페이지를 참조하기 위해 한 번
![alt text](<스크린샷 2024-04-15 052057.png>)

## TLB
페이지 테이블이 메모리에 있기에 발생하는 문제를 해결하기 위해 CPU 곁에 TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 둔다.
![alt text](<스크린샷 2024-04-15 052441.png>)

- TLB는 페이지 테이블의 일부를 가져와 저장한다.
- CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 TLB 히트
- 없을 경우 TLB 미스
![alt text](<스크린샷 2024-04-15 052456.png>)

# 페이징에서의 주소 변환
하나의 페이지 또는 프레임은 여러 주소를 포괄 그렇기에 특정 주소에 접근하려면 두 가지 정보가 필요하다.
- 어떤 페이지 혹은 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
![alt text](<스크린샷 2024-04-15 054920.png>)

페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지 번호**와 **변위**로 이루어져 있다.
(CPU가 해당 주소를 찾을때)
- 페이지 번호: 접근하고자 하는 페이지 번호
- 변위: 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보
![alt text](<스크린샷 2024-04-15 055612.png>)
페이지 번호를 알아도 실제 접근시에는 프레임 번호가 필요하기에 아래와 같이 된다.
![alt text](<스크린샷 2024-04-15 055617.png>)

아래 예제를 보자
CPU가 5번 페이지, 변위 2라는 논리 주소 <5, 2>에 접근한다고 가정시
- 5번 페이지의 프레임 번호는 1번지
- 물리 조소 공간에서 1번 프레임의 시작 번지는 8번지 변위는 2, 즉 10번지에 접근한다.

![alt text](<스크린샷 2024-04-15 055624.png>)

# 페이지 테이블 엔트리
페이지 테이블의 각각의 행들을 페이지 테이블 엔트리라고 한다.
- 이전 설명에서는 페이지, 프레임 번호만을 설명함
- 지금 부터는 그 이외에 담기는 중요한 것들을 설명할 것이다.
![alt text](<스크린샷 2024-04-15 060310.png>)

## 유효 비트
해당 페이지에 접근 가능한지 여부를 알려준다.
- 프로세스를 이루는 모든 페이지가 메모리에 있지는 않다.(스와핑)
- 페이지가 메모리에 적재됬는지(1), 보조기억장치에 적재되어있는지 알려주는 비트(0)
만약 유효비트가 0인 상태로 페이지로 접근할려고 할 시 **페이지 폴트**라는 예외가 발생한다.
![alt text](<스크린샷 2024-04-15 060740.png>)

## 보호 비트
페이지 보호 기능을 위해 존재하는 비트
- 읽고 쓰기가 모두 가능한 페이지인지, 읽기만 가능한 페이지인지를 나타낼 수 있다.
![alt text](<스크린샷 2024-04-15 063907.png>)

세 개의 비트로 조금 더 복잡하게 구현할 수도 있다.
![alt text](<스크린샷 2024-04-15 063915.png>)

## 참조 비트
CPU가 해당 페이지에 접근한 적이 있는지 여부를 나타낸다.
![alt text](<스크린샷 2024-04-15 063922.png>)

## 수정 비트
해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다.
더티 비트라고도 부른다.
![alt text](<스크린샷 2024-04-15 063927.png>)

페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재한다.
- CPU가 한번도 접근하지 않았거나 읽기만 한 페이지의 경우 보조기억장치에 저장된 해당 페이지의 내용과 메모리에 저장된 페이지 내용은 아래 그림과 같이 서로 같은 값을 가지고 있다.
- 한 번도 수정되지 않은 페이지가 스왑 아웃될 경우 아무런 추가 작업 없이 새로 적재된 페이지로 덮어쓰기만 하면된다.

![alt text](<스크린샷 2024-04-15 063938.png>)

수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가 되어야한다.
![alt text](<스크린샷 2024-04-15 063945.png>)