14-1 연속 메모리 할당

# 스와핑
사용하지 않는 메모리 공간을 확보하는 방식을 말한다.(자세한 설명은 밑에서)

- 메모리에 적재되었지만 사용하지 않은 프로세스가 있을 수 있다.
- 예를 들어 입출력 작업의 요구와 같은 작업으로 대기 상태가 된 프로세스라던지...
- 오랫동안 사용되지 않은 프로세스와 같은 것들을 말한다.
- 이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고
- 그렇게 해 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 말한다.

- 이때 프로세스들이 쫓겨나는 보조기억장치의 일부 영역을 **스왑 영역**
- 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것을 **스왑 아웃**
- 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 **스왑 인**
- 스왑 아웃 -> 스왑 인 될때는 원래 전의 물리주소와는 다른 주소에 적재될 수 있다.
![alt text](<스크린샷 2024-04-15 030255.png>)  


스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.

![alt text](<스크린샷 2024-04-15 030549.png>)

# 메모리 할당
프로세스는 메모리 내의 빈 공간에 적재되어야 한다. 이때 빈 공간이 여러 개 있다면? 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식을 설명할 것이다.
(빈 공간이 여러개라는 말은 군데 군데 있다는 말이다.)

![alt text](<스크린샷 2024-04-15 031325.png>)

## 최초 적합
운영체제가 메모리 내의 빈 공간을 순서대로 검색하며 적재할 수 있는 공간을 발견시 그 공간에 프로세스를 배치하는 방법이다.

- 예를 들어 빈 공간 A -> 빈 공간 B -> 빈 공간 C 순서대로 운영체제가 빈 공간을 검색 했다면
- 프로세스는 빈 공간 A에 최초 적재 된다.

### 특징
공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화할 수 있고 결과적으로 빠른 할당이 가능하다.

- 궁금증
만약에 적재할 수 있는 공간이 부족하다면?

![alt text](<스크린샷 2024-04-15 031717.png>)

## 최적 적합
운영체제가 빈 공간을 모두 검색해 본 후, **프로세스가 적재될 수 있는 공간 중 가장 작은 공간**에 프로세스를 배치하는 방식

- 그림과 같은 경우에는 빈 공간 C에 적재가 된다.
![alt text](<스크린샷 2024-04-15 032051.png>)


## 최악 적합
운영체제가 빈 공간을 모두 검색해 본 후, **프로세스가 적재될 수 있는 공간 중 가장 큰 공간**에 프로세스를 배치하는 방식이다.

- 해당 방식의 경우 빈 공간 B에 적재될 것이다.
![alt text](<스크린샷 2024-04-15 032130.png>)


# 외부 단편화
일단 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법이 아니다. 해당 이유는 외부 단편화 때문이지만 이에 대한건 밑의 간단한 예시로 알아보자.

1. 아무런 프로세스도 적재 되지 않은 상태의 메모리
![alt text](<스크린샷 2024-04-15 032939.png>)

2. 사용자 영역의 크기는 200MB로 가정
- 크기가 50MB인 프로세스 A
- 크기가 30MB인 프로세스 B
- 크기가 100MB인 프로세스 C
- 크기가 20MB인 프로세스 D를 차례대로 적재
![alt text](<스크린샷 2024-04-15 033051.png>)

3. 프로세스 B와 D의 실행이 종료 후 B와 D가 메모리를 떠날 시 빈 공간이 생긴다.
![alt text](<스크린샷 2024-04-15 033134.png>)

위의 그림을 보았을 때도 알다 싶이 메모리의 남은 공간은 50MB가 될 것이다. 하지만 정작 50MB 크기의 프로세스가 적재될 수 없다.
실제로는 프로세스가 실행, 종료를 반복하며 위와 같은 상황이 빈번하게 발생될 텐데 그럴시 메모리 사이 사이에 빈 공간들이 생길 것이고,
빈 공간의 총 합 보다 실질적으로 큰 프로세스를 적재하기 어려운 상황이 초래될 것이다. 

- 결과적으로는 메모리 낭비로 이어질 것이다. 그리고 이러한 현상을 **외부 단편화**라고 한다.
- 즉 외부 단편화는 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상을 의미한다.

## 해결(압축)
메모리 공간을 효율적으로 사용하기 위해서라도 외부 단편화는 반드시 해결해야 하는 문제중 하나이다.

- 대표적인 방안으로는 메모리를 압축 하는 방법이 있다.
- 압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식이다.
- 메모리 내에 저장된 프로세스를 적당히 재배치 하여 흩어진 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법이다.

![alt text](<스크린샷 2024-04-15 033605.png>)

## 압축의 단점
- 작은 빈 공간을 하나로 모으는 동안 시스템은 하던 일을 중지해야한다.
- 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기
- 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법의 결정이 힘듬


# 내부 단편화
페이징 개념에서 나오는 부분

- 페이징 기술로 외부 단편화 문제를 해결할 수 있지만 내부 단편화 문제가 있다.
- 페이징에서 프로세스를 일정한 크기로 나눌때 모든 프로세스가 페이지 크기에 맞게 잘리는 것은 아니다.
- 마지막 부분에서 남는 부분이 있으므로 그 부분은 또 메모리 공간의 낭비로 이어진다. 이를 내부 단편화라고 한다.